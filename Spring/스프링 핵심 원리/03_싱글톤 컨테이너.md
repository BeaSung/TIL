## 싱글톤 패턴 (Singleton Pattern)
**싱글톤 패턴** : 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
```java
public class SingletonService {

    //1. static 영역에 객체를 딱 1개만 생성해둔다.
    private static final SingletonService instance = new SingletonService();

    //2. public으로 열어서 객체 인스턴스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
    public static SingletonService getInstance() {
        return instance;
    }

    //3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다.
    private SingletonService() {
    }

    public void logic() {
        System.out.println("싱글톤 객체 로직 호출");
    }
}
```
- static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.
- 이 객체 인스턴스가 필요하면 오직 getInstance()메서드를 통해서만 조회할 수 있다.
- 딱 1개의 객체 인스턴스만 존재해야하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.


### 위와 같은 방식의 싱글톤 패턴의 문제점
1. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
2. 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다.
3. 테스트하기 어렵다.
4. 내부 속성을 변경하거나 초기화 하기 어렵다.
5. private 생성자로 자식 클래스를 만들기 어렵다.
6. 유연성이 떨어진다.

<br>

## 싱글톤 컨테이너
싱글톤 컨테이너는 싱글톤 패턴의 문제점을 해결하면서 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 스프링 빈이 바로 싱글톤으로 관리되는 객체다.

- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
- 스프링 컨테이너의 이러한 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
  - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않는다.
  - DIP, OCP를 위반하지 않는다.
  - 테스트가 용이해진다.

### 싱글톤 방식의 주의점
싱글톤 객체는 전역에서 공유되는 객체이므로 멀티쓰레드 환경에서의 동시성 문제를 주의해야 한다. <br>
따라서 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하므로 **싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다!** 

즉, 다음과 같이 **무상태(stateless)**로 설계해야한다.

1. 특정 클라이언트에 의존적인 필드가 있어선 안 된다.
2. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
3. 가급적 읽기만 가능해야 한다.
4. 필드 대신 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

스프링 빈의 필드에 공유 값을 설정하면 매우 큰 장애가 발생할 수 있으므로 주의하자. 따라서 **스프링 빈은 항상 무상태(stateless)로 설계하자.**

<br>

## @Configuration과 싱글톤
스프링이 CGLIB 바이트코드 조작 라이브러리를 사용하여 만든 클래스가 스프링 빈의 싱글톤을 보장해준다.<br>
아마도 다음과 같이 바이트 코드를 조작해서 작성되어있을 것이다. (실제로는 CGLIB의 내부 기술을 사용하는데 매우 복잡하다.)
````java
@Bean
public MemberRepository memberRepository() {
    if(memorymemberRepository가 이미 스프링 컨테이너에 등록되어있으면?) {
        return 스프링 컨테이너에서 찾아서 반환;
    } else { // 스프링 컨테이너에 없으면
        기존로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록
        return 반환;
    }
}
````
즉, `@Bean`이 등록된 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. 이 덕분에 싱글톤이 보장된다.

이때, AppConfig를 `@Configuration`을 적용하지 않고, `@Bean`만 적용한다면 스프링 빈으로 등록되기는 하지만 CGLIB으로 바이트코드 조작되어 싱글톤을 보장하는 빈이 등록되지 않고, 순수 자바 객체가 등록된다. 따라서 싱글톤이 보장되지 않는다.

결론은, 스프링 설정 정보는 `@Bean`이 아닌 `@Configuration`을 사용해야 한다는 것이다!


<br>
<br>

### 레퍼런스
- [김영한 - 스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard "인프런 강의")
