## 11장 클라이언트 식별과 쿠키

## 목차
[1. 개별 접촉](#개별-접촉)

[2. HTTP 헤더](#HTTP-헤더)

[3. 클라이언트 IP 주소](#클라이언트-IP-주소)

[4. 사용자 로그인](#사용자-로그인)

[5. 쿠키](#쿠키)



## 개별 접촉
HTTP는 익명으로 사용하며 **상태가 없고** 요청과 응답으로 통신하는 프로토콜이다.
<br>
웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
- `HTTP의 무상태(Stateless) / 상태가 없다` : 연결 자체에 대한 정보를 가지지 않으며 매 요청은 일회성이고 독립적으로 처리된다.
<br>
HTTP가 사용자를 식별하는 데 사용하는 기술들

- 사용자 식별 관련 정보를 전달하는 **HTTP 헤더**들
- 클라이언트 IP 주소 추적으로 알아낸 **IP 주소**로 사용자를 식별
- 사용자 **로그인 인증**을 통한 사용자 식별
- URL에 식별자를 포함하는 기술인 **뚱뚱한(fat)URL**
- 식별 정보를 지속해서 유지하는 강력하면서도 효율적인 기술인 **쿠키**
<br>

## HTTP 헤더
사용자에 대한 정보를 전달하는 가장 일반적인 일곱 가지 HTTP헤더

|헤더 이름|헤더 타입|설명|
|------|---|-----------------------------------|
|From|요청|사용자의 이메일 주소|
|User-Agent|요청|사용자의 브라우저|
|Referer|요청|사용자가 현재 링크를 타고 온 근원 페이지|
|**Authorization**|요청|사용자 이름과 비밀먼호|
|Client-ip|확장(요청)|클라이언트의 IP 주소|
|X-Forwarded-For|확장(요청)|클라이언트의 IP 주소|
|Cookie|확장(요청)|서버가 생성한 ID 라벨|

- From 헤더를 보내는 브라우저는 많지 않다.
- User-Agent 헤더는 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 어떤 경우에는 운영체제에 대한 정보까지 포함하여 서버에게 알려준다. 이는 특정 브라우저에서 제대로 동작하도록 그것들의 속성에 맞추어 콘텐츠를 최적화하는 데 유용할 수 있지만, **특정 사용자를 식별하는 데는 큰 도움이 되지 않는다.**
- Referer 헤더는 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다. **Referer 헤더 자체만으로 사용자를 식별할 수는 없지만,** 사용자가 이전에 어떤 페이지를 방문했었는지는 알려준다.
<br>


## 클라이언트 IP 주소
클라이언트 IP 주소로 사용자를 식별하는 방식의 **약점들**
- 클라이언트 IP 주소는 사용자가 아닌, 사용하는 컴퓨터를 가리킨다. **만약 여러 사용자가 같은 컴퓨터를 사용한다면 그들을 식별할 수 없을 것이다.**
- 보통 **HTTP 프락시**와 **게이트웨이**는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트의 IP 주소를 본다. 일부 프락시는 원본 IP 주소를 보존하려고 **Client-ip**나 **X-Forwarded-For HTTP** 같은 **확장 헤더**를 추가하여 이 문제를 해결하려 했다. 하지만 모든 프락시가 이런 식으로 동작하진 않는다.
- 아직도 세션 간에 사용자를 추적하려고 클라이언트 IP 주소를 사용하는 웹사이트가 있지만, **이 방식은 제대로 동작하지 않기 때문에 사용하지 않는다.**
<br>


## 사용자 로그인
웹 서버는 사용자 이름과 비밀번호로 **인증(로그인)** 할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
<br>
웹 사이트 로그인이 더 쉽도록 HTTP는 `WWW-Authenticate`와 `Authorization 헤더`를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
<br>
한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.
<br>

HTTP 인증 헤더를 사용하여 사용자 등록하기
- 브라우저가 해당 사이트로 요청한다.
- 사이트는 사용자의 식별정보를 알지 못하므로, 서버는 401 Login Required HTTP 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인하라고 요청한다. 
- 사용자가 사용자 이름과 비밀번호를 입력하고 브라우저는 기존 요청을 다시 보내서 사용자 식별을 시도한다.
- 이제 서버는 사용자의 식별정보를 안다.
- 사이트에 한 번만 로그인하면, 브라우저는 요청마다 해당 사용자의 식별정보 토근을 Authorization 헤더에 담아 서버로 전송해서, 한 세션이 진행되는 내내 그 사용자에 대한 식별을 유지한다.
<br>


## 쿠키
쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.

#### 쿠키의 타입
- `세션 쿠키(session cookie)`
  - **임시 쿠키**
  - 사용자가 브라우저를 닫으면 삭제된다.
- `지속 쿠키(persistent cookie)`
  - 디스크에 저장되어, 브라우저를 닫거나 **컴퓨터를 재시작하더라도 남아있다.**
  - 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.
- 둘의 차이점
  - 파기되는 시점
  - 파기되기까지 남은 시간을 가리키는 Expires 혹은 Max-Age 파라미터가 없으면 세션 쿠기가 된다.
<br>


#### 쿠키는 어떻게 동작하는가
- 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
- 쿠키는 임의의 **이름=값** 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie2(확장 헤더) 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달한다.
- 쿠키는 어떤 정보든 포함할 수 있지만, 서버가 사용자 추적 용도로 생성한 유일한 단순 식별 번호만 포함하기도 한다.
- 서버는 이 쿠키 값으로 데이터베이스에서 사용자의 정보(구매 내용, 주소 정보 등)를 찾는데 사용할 수 있다.
<br>


#### 쿠키상자: 클라이언트 측 상태
쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 전송하게 하는 것.
<br>

**구글 크롬 쿠키**
- 각 브라우저는 다른 방식으로 쿠키를 저장한다. **구글 크롬은 Cookies라는 `SQLite 파일`에 쿠키를 저장한다.**
- 총 13개의 필드 중 주요 필드
  - `host_key` : 쿠키의 도메인
  - `name` : 쿠키의 이름
  - `value` : 쿠키의 값
  - `expire_utc` : 쿠키의 파기 시점
  - `secure` : 이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다.
<br>


#### 사이트마다 각기 다른 쿠키들
브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다. joes-hardware.com에서 생성된 쿠키는 joes-hardware.com에만 보내고 bobs-books.com이나 marys-movie.com에는 보내지 않는다.
<br>
**쿠키 Domain 속성**
<br>
서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다. <br>
예를 들어, 다음 HTTP 응답 헤더는 브라우저가 user="mary17"이라는 쿠키를 .airtravelbargains.com 도메인을 가지고 있는 모든 사이트에 전달한다는 의미다.
```java
Set-cookie: user="mary17"; domain="airtravelbargains.com"
```
<br>


#### Version 0(넷스케이프) 쿠키
**Version - Set-Cookie 헤더**
Set-Cookie 헤더는 쿠키의 이름과 같은 값을 가져야 한다. 이는 쿠키 옵션 속성들에 세미콜론으로 이어 기술한다.
<br>

Version 0(넷스케이프) Set-Cookie 속성

|Set-Cookie 속성|설명과 용례|
|--------------|----------|
|이름=값|Set-Cookie: customer=Mary|
|Expires|Set-Cookie: foo=bar; expires=Wednesday, 09-Nov-99 23:12:40 GMT|
|Domain|브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트 명으로만 쿠키를 전송한다. 도메인이 명시되어 있지 않으면, Set-Cookie 응답을 생성한 서버의 호스트 명을 기본값으로 사용한다.|
|Secure|이 속성이 포함되어 있으면, 쿠키는 HTTP가 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.|
<br>

**Version 0 Cookie 헤더**
클라이언트가 서버에 요청을 보낼 때는, Domain, Path, Secure 필터들이 현재 요청하려고 하는 사이트에 들어맞으면서 아직 파기되지 않은 쿠키들을 함께 보낸다. **모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보낸다.**
<br>


#### 쿠키와 캐싱
쿠키 트랜잭션과 관련된 **문서를 캐싱하는 것은 주의해야 한다.** 누군가의 개인 정보가 다른 이이게 노출되는 최악의 상황이 일어날 수도 있다. 쿠키와 캐싱에 관련된 규칙은 정리가 잘 되어 있지 않다. 
<br>

**캐시를 다루는 기본 원칙**
- **캐시되지 말아야 할 문서가 있다면 표시하라**
  - 만약 문서가 Set-Cookie 헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 Cache-Control: no-cache="Set-Cookie"를 기술해서 명확히 표시한다. 또한, 캐시를 해도되는 문서에 Cache-Control: public을 사용하면 웹의 대역폭을 더 절약시켜준다.
- **Set-Cookie 헤더를 캐시 하는 것에 유의하라**
  - 같은 Set-Cookie 헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패할 것이다.
- **Cookie 헤더를 가지고 있는 요청을 주의하라**
  - 요청이 Cookie 헤더와 함께 오면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다는 힌트다. 개인정보는 캐시되지 않도록 표시되어 있어야 하지만, 그 표시를 하지 않는 서버도 있다.
<br>


#### 쿠키, 보완 그리고 개인정보
- 사실 원격 데이터베이스에 개인 정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면, 클라이언트와 서버 사이에 예민한 데이터가 오가는 것을 줄일 수 있다.
- 쿠키에 대한 부정적인 여론이 많기는 하지만, 제공하는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.
