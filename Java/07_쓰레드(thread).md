## 프로세스 & 쓰레드(process & thread)
- `프로세스` : 실행중인 프로그램, **자원(Resource)과 쓰레드로 구성**
- `쓰레드` : 프로세스 내에서 실제 작업을 수행, **모든 프로세스는 최소한 하나 이상의 쓰레드를 가지고 있음** 
- `싱글 쓰레드` : 자원+쓰레드
- `멀티 쓰레드` : 자원+쓰레드+쓰레드+쓰레드+...
- 하나의 새로운 쓰레드를 생성하는게 **더 적은 비용이 듬** (공장 새로 짓느니 일꾼을 더 고용)

#### 멀티쓰레드의 장단점
- 대부분의 프로그램이 멀티쓰레드로 작성되어 있다.
- **장점**
  - 여러모로 좋다
    - 자원의 **효율적** 사용
    - 사용자에 대한 **응답성 향상**(채팅)
    - 작업 분리되어 **코드간결**
- **단점**
  - 프로그래밍할 때 고려해야 할 사항들이 많다.
    - 동기화(sync.)주의
    - 교착상태(dead-lock)가 발생하지 않게 주의
    - 각 쓰레드가 효율적으로 고르게 실행될 수 있도록 해야함
<br>

## 쓰레드의 구현과 실행
#### 쓰레드의 구현
1. Thread 클래스 상속
  ```Java
  class MyThread extends Thread {
    public void run() {   // Thread 클래스의 run()을 오버라이딩
      /* 작업내용 */
    }
  }
  ```
2. **Runnable 인터페이스 구현**  <- 상속보다 인터페이스 구현을 선호(2개 이상의 인터페이스를 샹속할 수 있다)
  ```Java
  class MyThread2 implements Runnable {
    public void run() {   // runnable 인터페이스의 추상메서드 run()을 구현
      /* 작업내용 */
    }
  }
  ```
  
#### 쓰레드의 실행
- `start()` : 쓰레드를 생성 후 **start()를 호출해야** 작업시작 
- 쓰레드를 나누어 돌리면 **번갈아서 실행**된다.
- start()를 먼저 했다고 해서 먼저 실행되는것이 아니다.
- start()는 새로운 스택을 생성하고, 그 생성된 스택에서 run메소드를 실행한다.

#### 쓰레드 실행 방법
- 쓰레드를 실행하는 방법은 2가지가 있음.

1. **Thread 클래스를 상속** 받은 경우(위의 1번 경우)
  ```Java
  MyThread t1 = new MyThread();   // 쓰레드의 생성
  t1.start();   // 쓰레드의 실행
  ```
2. **Runnable 인터페이스를 구현**하는 경우(위의 2번 경우)
  ```Java
  Runnable r = new MyThread2();
  Thread2 t2  = new Thread(r)   // Thread(Runnable r)
  // Thread t2 = new Thread(new MyThread2());
  t2.start();   // 쓰레드의 실행
  ```


## 싱글 쓰레드와 멀티 쓰레드

#### main쓰레드(사용자 스레드)
- `사용자 쓰레드` : main메서드의 코드를 수행
- `데몬 쓰레드` - 일종의 **보조스레드**(사용자 쓰레드가 하는 역할을 보조해 줌)
- 프로그램은 실행 중인 사용자 쓰레드가 **하나도 없으면 프로그램은 종료**된다
- 메인메서드가 종료돼도, **다른 스레드가 실행중이면 프로그램은 종료되지 않음**

#### 멀티 쓰레드
- `ContextSwitching` : A작업 -> B작업
- 멀티쓰레드는 contextswitching(작업간 이동)탓에 **시간은 더 걸리지만 여러작업 동시진행이라서 효율적** 예) 채팅

#### 쓰레드의 I/O블락킹(blocking)
- `IO 블락킹` : **입출력 시 작업 중단**, 자원을 효율적으로 사용하기 위해(놀고있는 쓰레드를 최소화)
- 멀티쓰레드는 작업 수행동안 외부 요인 탓에 멈춰지더라도 **다른 쓰레드가 작업 진행** -> 효율적 + 빨리 끝남. (장점)

