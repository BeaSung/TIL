## 애너테이션
- 에너테이션: 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서 유용한 정보제공
- 에너테이션의 등장배경
  - 소스변경에 따른 관련 문서의 불일치 발생 : 주석 적극 도입으로 코드상에서 문서도 수정하게 함(문서와 코드를 합치다)
- **메타에너테이션** : 에너테이션 만들때 씀

## 표준 애너테이션
- `@Override` : 오버라이딩을 올바르게 했는지 체크, 메서드 이름이 오기 되는 경우가 많은데 이를 예방
- `@Deprecated` : 앞으로 사용하지 않을 것을 권장하는 필드나 메서드에 사용, 사용할 경우 경고메세지(recompile옵션으로 상세설명)
- `@FunctionalInterface` : 함수형 인터페이스에 붙이면 컴파일러가 올바르게 작성했는지 체크(함수형 if는 하나의 메서드를 가져야 한다는 제약이 있음) 
- `@SuppressWarnings` : 컴파일러의 경고메세지가 나타나지 않게 함, 괄호 안에 억제하고자 하는 경고의 종류를 문자열로 지정
  - Xlint 옵션으로 컴파일 하면, 경고메세지 확인 가능, 괄호 안이 경고의 종류 아래의 경우 rawtypes

## 메타 애너테이션
- **메타 에너테이션** : 에너테이션을 위한 에너테이션
- `@Target` : 적용대상 지정에 사용
- `@Retention` : 에너테이션 유지되는 기간을 지정하여 사용
* compiler에 의해 사용되는 에너테이션 유지정책 -> SOURCE
* 실행 시 사용가능 에너테이션 정책 -> RUNTIME
- `@Documented` : javadoc 작성 문서 포함
- `@Inherited` : 에너테이션을 자손 클래스에 상속
- `@Repeatable` : 반복 해서 붙일 수 있는 에너테이션

## 애너테이션 타입 정의하기
- **에너테이션 타입 정의** : 에너테이션을 직접 만들 수 있음
  ```Java
  @interface TestInfo {  // 애너테이션 이름
    int count();  //타입 요소이름
    String testedBy();
    String[] testTools();
  }
  ```
- 에너테이션의 메서드는 추상 메서드, 에너테이션 적용 시 지정(순서x)

#### 에너테이션 요소
- 적용 시 값지정 안하면 사용가능한 **기본값 지정가능(null제외)**
- 단일 요소이고 이름이 **value**이면 요소이름 **생략가능**
- 요소 타입이 배열이면 {}사용
  ```Java
  @Test(testTools = {"Junit", "AutoTester"})
  @Test(testTools = "Junit")  // 값이 하나일 때는 괄호 필요x
  @Test(testTools = {})   // 값이 없을 때도 {}가 반드시 필요
  ```
- 모든 에너테이션의 조상
  - 모든 애너테이션의 조상이지만 **상속은 불가**
  - 애너테이션은 **인터페이스**이다.

- `마커 에너테이션(Marker Annotation)` : 요소가 하나도 정의되지 않은 애너테이션

#### 에너테이션 요소와 규칙
- 요소 타입은 **기본형, String, enum, 에너테이션, Class**만 선언
- 괄호()안 매개변수 선언 x
- 예외 선언 x
- 요소를 타입 매개변수로 정의 x

